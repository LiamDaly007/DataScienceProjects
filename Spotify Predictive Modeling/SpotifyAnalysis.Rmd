---
title: "Regression Analysis on a Spotify Dataset: Predicting Track Popularity" 
author: "Liam Daly, Tristan Dull, Daniel Khan, Aaron Bajorunas, Christopher Chen"
date: '2023-12-14'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 


library("tidyverse")
library("ggplot2") 
library("gridExtra")
library("GGally")
library("car")
```

\newpage 
\tableofcontents 
\newpage
\listoffigures
\newpage
\listoftables
\newpage

# Introduction

For our group project project we will be analyzing a real-world Spotify dataset with over 80k observations of 21 different variables. Our main goal is to attempt to create linear regression models in order to make inferences on the following two response variables: track popularity and artist popularity.

## Research Question


Which predictors are most significant for predicting track popularity or artist popularity.



## Analysis Goal

Our main stakeholders in this scenario would be music industry executives interested to see which factors may influence popularity. Given the insights generated by our analysis, they may be able to allocate resources toward improving certain factors for the sake of generating more popularity.

# Data Description

## Variables and Summary Statistics

# Exploratory Data Analysis

## Data Cleaning

```{r}
#change to your computer
spotify <- read_csv("/Users/liamdaly/Downloads/playlist_2010to2023.csv")
```


```{r}
spotify
```

```{r}
nrow(spotify)
```



Upon looking through the entire dataset, it's clear that it isn't fit for analysis straight away. There are many NA entries, so I'll first remove all rows containing NA values.

```{r}
library(dplyr)

hostel <- spotify %>%
  filter(complete.cases(spotify))
```

```{r}
spotify
```

Now, we'll need to remove any duplicate tracks.

```{r}
# removing duplicate tracks
spotify <- spotify %>% distinct(track_id, .keep_all = TRUE)
```


```{r}
nrow(spotify)
```

There was a total of 98 duplicates.

```{r}
spotify
```


We also need to remove irrelevant categorical variables. We found these variables had far too many categories and were unfit to include in our analysis moving forward.

```{r}
spotify <- spotify |>
  dplyr::select(-playlist_url, -track_id, -track_name, -album, -artist_id, -artist_name, -artist_genres)
```


```{r}
spotify
```

## Visualizations

### Response Variable Plot

```{r}
ggplot(data = spotify, aes(x = track_popularity)) +
  geom_histogram(fill = "#FF6961", color = 1) +
  labs(title = "Track Popularity Histogram", x = "Track Popularity", y = "Frequency")
```



### Predictor Plots


Number of tracks per year:

```{r}
year_counts <- spotify |>
  group_by(year) |>
  summarise(count = n())

ggplot(year_counts, aes(x = factor(year), y = count)) +
  geom_bar(stat = "identity", fill = "#1DB954") +
  theme_minimal() +
  labs(title = "Number of Tracks per Year",
       x = "Year",
       y = "Number of Tracks") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Relatively even number of tracks per each year.


Number of tracks per key:

```{r}
key_counts <- spotify |>
  group_by(key) |>
  summarise(count = n())

ggplot(key_counts, aes(x = factor(key), y = count)) +
  geom_bar(stat = "identity", fill = "#1DB954") + 
  theme_minimal() +
  labs(title = "Number of Tracks per Key",
       x = "Key",
       y = "Number of Tracks") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

There appears to be a mixed amount of representation from each key.


Number of tracks per mode:

```{r}
mode_counts <- spotify |>
  group_by(mode) |>
  summarise(count = n())

ggplot(mode_counts, aes(x = factor(mode), y = count)) +
  geom_bar(stat = "identity", fill = "#1DB954") + 
  theme_minimal() +
  labs(title = "Number of Tracks per Mode",
       x = "Mode",
       y = "Number of Tracks") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

More reprentation from tracks of mode = 1.

```{r}
time_signature_counts <- spotify |>
  group_by(time_signature) |>
  summarise(count = n())

ggplot(time_signature_counts, aes(x = factor(time_signature), y = count)) +
  geom_bar(stat = "identity", fill = "#1DB954") +  
  theme_minimal() +
  labs(title = "Number of Tracks per Time Signature",
       x = "Time Signature",
       y = "Number of Tracks") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


Vast majority of tracks are of time signature 4.



Visualizing all continuous variables in a grid format:

```{r}
plot_danceability <- ggplot(spotify, aes(x = danceability)) +
  geom_histogram(binwidth = 0.05, fill = "#1DB954", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Danceability", x = "Danceability", y = "Count")

plot_energy <- ggplot(spotify, aes(x = energy)) +
  geom_histogram(binwidth = 0.05, fill = "#1DB954", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Energy", x = "Energy", y = "Count")

plot_loudness <- ggplot(spotify, aes(x = loudness)) +
  geom_histogram(binwidth = 1, fill = "#1DB954", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Loudness", x = "Loudness", y = "Count")

plot_speechiness <- ggplot(spotify, aes(x = speechiness)) +
  geom_histogram(binwidth = 0.05, fill = "#1DB954", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Speechiness", x = "Speechiness", y = "Count")

plot_acousticness <- ggplot(spotify, aes(x = acousticness)) +
  geom_histogram(binwidth = 0.05, fill = "#1DB954", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Acousticness", x = "Acousticness", y = "Count")

plot_instrumentalness <- ggplot(spotify, aes(x = instrumentalness)) +
  geom_histogram(binwidth = 0.05, fill = "#1DB954", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Instrumentalness", x = "Instrumentalness", y = "Count")

plot_liveness <- ggplot(spotify, aes(x = liveness)) +
  geom_histogram(binwidth = 0.05, fill = "#1DB954", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Liveness", x = "Liveness", y = "Count")

plot_valence <- ggplot(spotify, aes(x = valence)) +
  geom_histogram(binwidth = 0.05, fill = "#1DB954", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Valence", x = "Valence", y = "Count")

plot_tempo <- ggplot(spotify, aes(x = tempo)) +
  geom_histogram(binwidth = 5, fill = "#1DB954", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Tempo", x = "Tempo", y = "Count")

plot_duration <- ggplot(spotify, aes(x = duration_ms)) +
  geom_histogram(binwidth = 30000, fill = "#1DB954", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Duration", x = "Duration (ms)", y = "Count")

plot_time_signature <- ggplot(spotify, aes(x = time_signature)) +
  geom_histogram(binwidth = 1, fill = "#1DB954", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Time Signature", x = "Time Signature", y = "Count")

grid.arrange(
  plot_danceability, plot_energy, plot_loudness,
  plot_speechiness, plot_acousticness, plot_instrumentalness,
  plot_liveness, plot_valence, plot_tempo,
  plot_duration, plot_time_signature,
  ncol = 3
)

```




This indicates some variables may be highly correlated to one another.



Number of tracks per level of artist popularity:

```{r}
plot_time_signature <- ggplot(spotify, aes(x = artist_popularity)) +
  geom_histogram(binwidth = 1, fill = "#1DB954", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Artist Popularity", x = "Time Signature", y = "Count")

plot_time_signature

```

### Correlation Visualization

```{r}
placement1 <- read.csv("/Users/liamdaly/Downloads/Placement_Data_Full_Class.csv")
library(RColorBrewer)
library(ggplot2)
library(reshape2)
corr_mat <- round(cor(spotify),2)
 
melted_corr_mat <- melt(corr_mat)

 
# plotting the correlation heatmap
library(ggplot2)
ggplot(data = melted_corr_mat, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile(color = "white")   +
  scale_fill_gradientn(colors = c("#FF6961", "white", "#FF6961"), 
                       limits = c(-1, 1), 
                       name = "Correlation") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 12, hjust = 1)) +
  labs(x = "", y = "") +
  coord_fixed() +
  geom_tile()
```

Correlation plot doesn't indicate any serious problems. I'll check the specific correlation coefficient between the following pairs of variables:

acoustincess and energy
loudness and energy

```{r}
cor(spotify$acousticness, spotify$energy)
```

```{r}
cor(spotify$loudness, spotify$energy)
```

These values are highly correlated but they're below the abs(.7) threshold so we'll keep them for now. If the vif scores of our full regression model are high, we'll consider removing more variables to account for potential multicollinearity.

# Model Building

## Full Model

```{r}
spotify
```


```{r}
m1 <- lm(track_popularity ~ year + artist_popularity + danceability + energy + key + 
           loudness + mode + speechiness + acousticness + instrumentalness + liveness + valence
         + tempo + duration_ms + time_signature, data = spotify)
summary(m1)
```

Our full model outputs an R squared of .08181 and an adjusted R squared of .07579. Only 8.181 percent of variability in track popularity is explained by this model. The R squared may be significantly low, but this is expected when working with real world data. Our goal moving forward is to determine if we can improve this model in any way.

At significance level alpha .1, there appears to be two significant predictors: artist_popularity and time_signature.

### Multicollinearity Analysis on Full Model

```{r}
vif(m1)
```


The VIF scores are all below 10, indicating multicollinearity is not an issue with this model.

## Full Model Assumption Checks

### Normality
```{r}
qqnorm(m1$residuals, main = "QQ plot on Full Model")
qqline(m1$residuals, col = "#1DB954")
```

```{r}
shapiro.test(m1$residuals)
```

QQline heavily deviates with respect to the normality assumption. Because of this, we decided to remove low outlier track popularity scores less than.

```{r}
ggplot(data = spotify, aes(x = track_popularity)) +
  geom_histogram(fill = "#FF6961", color = 1) +
  labs(title = "Track Popularity Histogram", x = "Track Popularity", y = "Frequency")
```

```{r}
spotify <- filter(spotify, track_popularity >= 45)
```


```{r}
ggplot(data = spotify, aes(x = track_popularity)) +
  geom_histogram(binwidth = 2, fill = "#FF6961", color = 1) +
  labs(title = "Track Popularity Histogram", x = "Track Popularity", y = "Frequency")
```


```{r}
#null model with no predictors
stepwise_null_model = lm(track_popularity ~ 1, spotify)

#full model with all relevant predictors
stepwise_full_model <- lm(track_popularity ~ year + artist_popularity + danceability + energy + key + 
           loudness + mode + speechiness + acousticness + instrumentalness + liveness + valence
         + tempo + duration_ms + time_signature, data = spotify)
```

```{r}
stepwise_model <- step(stepwise_null_model, scope = list(lower = stepwise_null_model, upper =
stepwise_full_model), direction = "both")
```


```{r}
summary(stepwise_model)
```

```{r}
vif(stepwise_model)
```

```{r}
qqnorm(stepwise_model$residuals)
qqline(stepwise_model$residuals)
```

```{r}
qqnorm(stepwise_model$residuals, main = "QQ plot after Stepwise Selection & Removing Outliers")
qqline(stepwise_model$residuals, col = "#1DB954")
```


```{r}
shapiro.test(stepwise_model$residuals)
```

```{r}
plot(stepwise_model)
```

```{r}
dwt(stepwise_model)
```





```{r}
spotify_dummy <- spotify |> dplyr::select(artist_popularity, year, speechiness, duration_ms, acousticness)
```




```{r}
cor(spotify_dummy)
```

### 
```{r}

```



### Validation

Lastly, we wanted to run a validation set approach to directly compare the full model with the stepwise model

```{r}
set.seed(167)
```


### Final Model

```{r}
m1 <- lm(track_popularity ~ year + artist_popularity + danceability + energy + key + 
           loudness + mode + speechiness + acousticness + instrumentalness + liveness + valence
         + tempo + duration_ms + time_signature, data = spotify)

```

```{r}
set.seed(167)
dim(spotify)

train.idx <- sample(2246, 1123)

train <- spotify[train.idx, ]
test <- spotify[-train.idx, ]

full.model.train <- lm(track_popularity ~ year + artist_popularity + danceability + energy + key + 
           loudness + mode + speechiness + acousticness + instrumentalness + liveness + valence
         + tempo + duration_ms + time_signature, data = train)

stepwise.model.train <- lm(formula = track_popularity ~ artist_popularity + year + speechiness + 
    duration_ms + acousticness, data = train)
```


Traning and Validation Set MSE for Full Model
```{r}
full.model.train.MSE <- mean((train$track_popularity - predict(full.model.train))^2)
full.model.test.MSE <- mean((train$track_popularity - predict(full.model.train, newdata = test))^2)
full.model.train.MSE
full.model.test.MSE
```

Traning and Validation Set MSE for Stepwise Model
```{r}
stepwise.model.train.MSE <- mean((train$track_popularity - predict(stepwise.model.train))^2)
stepwise.model.test.MSE <- mean((train$track_popularity - predict(stepwise.model.train, newdata = test))^2)
stepwise.model.train.MSE
stepwise.model.test.MSE
```





